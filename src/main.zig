// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

const std = @import("std");
const warn = std.debug.warn;
const assert = std.debug.assert;
var allocator = std.heap.c_allocator; // std.heap.page_allocator;

/// Load primitive values from a given class file.
fn loadT(comptime T: type, file: std.fs.File) !T {
    const size = @sizeOf(T);
    var buffer: [size]u8 = undefined;
    const n = try file.read(buffer[0..size]);
    assert(n == size);
    return std.mem.bigToNative(T, @bitCast(T, buffer));
}

/// Load bytes from a given class file.
fn loadBytes(len: usize, file: std.fs.File) ![]u8 {
    var buf = try allocator.alloc(u8, len);
    const n = try file.read(buf);
    assert(n == len);
    return buf;
}

// zig fmt: off
/// Name and type indices aggregate.
const NameAndType = struct {
    name: u16,
    t: u16
};
// zig fmt: on

// zig fmt: off
/// Field type.
const Field = struct {
    class: u16,
    name_and_type: u16
};
// zig fmt: on

/// Method type same to Field.
const Method = Field;

// zig fmt: off
/// Table 4.4-A. Constant pool tags (by section)
/// https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-4.html
const ConstTag = enum(u8) {
    unused = 0x0,
    utf8 = 0x1,
    class = 0x7,
    string = 0x8,
    field = 0x9,
    method = 0xa,
    name_and_type = 0xc
};
// zig fmt: on

/// Values in const pool
const Const = union(ConstTag) {
    utf8: []const u8,
    unused: bool,
    class: u16,
    string: u16,
    field: Field,
    method: Field,
    name_and_type: NameAndType,

    /// Destroys utf8 string.
    pub fn deinit(self: Const) void {
        switch (self) {
            .utf8 => allocator.destroy(self.utf8.ptr),
            else => {},
        }
    }

    /// Loads union fields from a given file.
    pub fn load(file: std.fs.File) !Const {
        return switch (@intToEnum(ConstTag, try loadT(u8, file))) {
            ConstTag.unused => Const{ .unused = true },
            ConstTag.class => Const{ .class = try loadT(u16, file) },
            ConstTag.string => Const{ .string = try loadT(u16, file) },
            ConstTag.utf8 => Const{ .utf8 = try loadBytes(try loadT(u16, file), file) },
            ConstTag.field => Const{
                .field = Field{
                    .class = try loadT(u16, file),
                    .name_and_type = try loadT(u16, file),
                },
            },
            ConstTag.method => Const{
                .method = Method{
                    .class = try loadT(u16, file),
                    .name_and_type = try loadT(u16, file),
                },
            },
            ConstTag.name_and_type => Const{
                .name_and_type = NameAndType{
                    .name = try loadT(u16, file),
                    .t = try loadT(u16, file),
                },
            },
        };
    }
};

const Class = struct {
    const_pool: []Const,

    pub fn deinit(self: Class) void {
        for (self.const_pool) |c| {
            c.deinit();
        }
    }

    pub fn load(file: std.fs.File) !Class {
        var ret: Class = undefined;
        var buffer: [4]u8 = undefined;
        const bytes_read = try file.read(buffer[0..buffer.len]);
        assert(buffer[0] == 0xca);
        assert(buffer[1] == 0xfe);
        assert(buffer[2] == 0xba);
        assert(buffer[3] == 0xbe);

        const minor = try loadT(u16, file);
        const major = try loadT(u16, file);
        warn("class file version {}.{}\n", .{ major, minor });
        assert(major >= 45);

        const len = try loadT(u16, file);
        warn("constant pool length: {}\n", .{len});
        ret.const_pool = try allocator.alloc(Const, len);
        // The constant_pool table is indexed from 1 to constant_pool_count - 1.
        // https://docs.oracle.com/javase/specs/jvms/se14/html/jvms-4.html#jvms-4.1
        warn("constant pool [\n", .{});
        defer warn("]\n", .{});
        for (ret.const_pool) |*v, i| {
            v.* = if (i == 0) Const{ .unused = true } else try Const.load(file);
            warn("  {}: {}\n", .{ i, v });
        }
        return ret;
    }
};

pub fn main() !void {
    // get args
    const args = try std.process.argsAlloc(allocator);
    defer std.process.argsFree(allocator, args);

    const path = args[1];
    const file = try std.fs.cwd().openFile(path, .{ .write = false });
    defer file.close();

    const c = try Class.load(file);
    defer c.deinit();
}

test "cafebabe" {
    const file = try std.fs.cwd().openFile("test/Add.class", .{ .write = false });
    defer file.close();

    const c = try Class.load(file);
    defer c.deinit();
    assert(c.const_pool[0].unused);
    assert(c.const_pool[1].method.class == 3);
    assert(c.const_pool[1].method.name_and_type == 12);
    assert(c.const_pool[2].class == 13);
    assert(c.const_pool[3].class == 14);
    assert(std.mem.eql(u8, c.const_pool[4].utf8, "<init>"));
    assert(std.mem.eql(u8, c.const_pool[5].utf8, "()V"));
    assert(std.mem.eql(u8, c.const_pool[6].utf8, "Code"));
    assert(std.mem.eql(u8, c.const_pool[7].utf8, "LineNumberTable"));
    assert(std.mem.eql(u8, c.const_pool[8].utf8, "add"));
    assert(std.mem.eql(u8, c.const_pool[9].utf8, "(II)I"));
    assert(std.mem.eql(u8, c.const_pool[10].utf8, "SourceFile"));
    assert(std.mem.eql(u8, c.const_pool[11].utf8, "Add.java"));
    assert(c.const_pool[12].name_and_type.name == 4);
    assert(c.const_pool[12].name_and_type.t == 5);
    assert(std.mem.eql(u8, c.const_pool[13].utf8, "Add"));
    assert(std.mem.eql(u8, c.const_pool[14].utf8, "java/lang/Object"));
}
